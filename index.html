<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>EPUB Reader ‚Äî Highlights + Export/Import</title>

<!-- B·∫ÆT BU·ªòC: JSZip tr∆∞·ªõc, r·ªìi epub.js -->
<script src="https://cdn.jsdelivr.net/npm/jszip/dist/jszip.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/epubjs/dist/epub.js"></script>

<style>
  :root{
    --bg:#0b1020; --card:#0e162b; --muted:#9aa4b2; --text:#eaf0ff; --line:#1f2b4a;
    --accent:#38bdf8; --orange:#f59e0b;
  }
  *{box-sizing:border-box}
  body{margin:0; color:var(--text); font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
       background:linear-gradient(120deg,#0b1020,#101736)}
  header{
    position:sticky; top:0; z-index:10; display:flex; gap:.6rem; align-items:center; flex-wrap:wrap;
    padding:.6rem .8rem; background:rgba(14,22,43,.9); backdrop-filter:blur(6px); border-bottom:1px solid var(--line)
  }
  .btn{border:1px solid #2a3a63; background:#152043; color:var(--text);
       padding:.5rem .8rem; border-radius:.6rem; cursor:pointer}
  .btn.primary{border-color:#3aa0ff; background:#16294b}
  .btn.warn{border-color:#f59e0b}
  .btn:disabled{opacity:.5; cursor:not-allowed}
  input[type="file"]{display:none}
  .chip{padding:.35rem .6rem; border:1px solid #2a3a63; border-radius:999px; font-size:.9rem}
  .grow{flex:1}
  #status{font-size:.9rem; color:var(--muted)}

  /* layout: TOC | reader | highlights */
  #wrap{display:grid; gap:.8rem; padding:.8rem; grid-template-columns:260px 1fr 340px; min-height:calc(100vh - 64px)}
  #toc,#notes{background:rgba(14,22,43,.6); border:1px solid var(--line); border-radius:.8rem; padding:.6rem; overflow:auto}
  #toc h3,#notes h3{margin:.2rem .4rem .6rem; color:#a7b4c9; font-size:.95rem}
  #toc a{display:block; color:#cfe3ff; text-decoration:none; padding:.35rem .45rem; border-radius:.4rem}
  #toc a:hover{background:#1a2647}

  #stage{background:rgba(14,22,43,.6); border:1px solid var(--line); border-radius:.8rem; position:relative; min-height:360px}
  #area{width:100%; height:100%; overflow:auto}
  #overlay{position:absolute; inset:0; display:none; place-items:center; background:rgba(16,23,54,.4); backdrop-filter:blur(2px)}

  /* highlight panel */
  .note{border:1px solid #2a3a63; border-radius:.6rem; padding:.5rem .6rem; margin:.45rem 0; background:#121c36}
  .note .row{display:flex; gap:.4rem; align-items:center}
  .note .jump{flex:1; text-align:left; color:#eaf0ff; background:transparent; border:none; cursor:pointer}
  .note small{color:#9fb3d1; display:block; margin-top:.25rem}
  .note .del{border:1px solid #3b4f85; background:#1c284a; color:#ffd7a1; border-radius:.4rem; padding:.2rem .45rem; cursor:pointer}
  .note .del:hover{border-color:#f59e0b}

  /* m√†u highlight trong n·ªôi dung */
  .epubjs-hl{background:rgba(245,158,11,.45) !important; box-shadow:0 0 0 2px rgba(245,158,11,.25) inset}

  @media (max-width:1100px){
    #wrap{grid-template-columns:1fr}
    #toc{max-height:230px}
    #notes{max-height:280px}
  }
</style>
</head>
<body>
<header>
  <label class="btn primary" for="file">üìñ Ch·ªçn EPUB</label>
  <input id="file" type="file" accept=".epub">

  <button id="prev" class="btn">‚üµ Prev</button>
  <button id="next" class="btn">Next ‚ü∂</button>
  <span class="chip">C·ª° ch·ªØ: <input id="font" type="range" min="80" max="160" value="100">%</span>

  <button id="addHL" class="btn warn" disabled>üñçÔ∏è Highlight (cam)</button>

  <span class="chip">Trang: <span id="loc">‚Äî</span></span>
  <div class="grow"></div>

  <!-- Export/Import -->
  <button id="exportBtn" class="btn" disabled>‚¨áÔ∏è Xu·∫•t</button>
  <label class="btn" for="importFile">‚¨ÜÔ∏è Nh·∫≠p</label>
  <input id="importFile" type="file" accept=".json">
  <span id="status">S·∫µn s√†ng. Ch·ªçn/k√©o‚Äëth·∫£ .epub</span>
</header>

<div id="wrap">
  <nav id="toc"><h3>M·ª•c l·ª•c</h3><div id="tocItems"></div></nav>

  <section id="stage">
    <div id="area" tabindex="0"></div>
    <div id="overlay" style="display:grid"><div>
      <div style="font-size:1.2rem; text-align:center">‚è≥ ƒêang m·ªü EPUB‚Ä¶</div>
    </div></div>
  </section>

  <aside id="notes">
    <h3>Highlights (cam)</h3>
    <div id="noteList"></div>
  </aside>
</div>

<script>
(() => {
  const $ = id => document.getElementById(id);
  const fileInput = $('file'), area = $('area'), stage = $('stage'), overlay = $('overlay');
  const prevBtn = $('prev'), nextBtn = $('next'), fontRange = $('font'), addHLBtn = $('addHL');
  const loc = $('loc'), status = $('status'), tocItems = $('tocItems'), noteList = $('noteList');
  const exportBtn = $('exportBtn'), importFile = $('importFile');

  let book = null, rendition = null;
  let lastSelection = null;       // { cfi, text }
  let currentEpubName = '';       // "Thanh cong.epub"
  let currentEpubBase = '';       // "Thanh cong"
  let idSeq = 1;

  // store highlights: { id, cfi, text, chapter }
  const highlights = [];

  function setStatus(s){ status.textContent = s; }
  function clearTOC(){ tocItems.innerHTML = ""; }

  function ensureHeight(){
    const h = stage.clientHeight || 420;
    area.style.height = h + 'px';
  }
  new ResizeObserver(ensureHeight).observe(stage);
  ensureHeight();

  // ===== TOC: click ƒë·ªÉ nh·∫£y ƒë·∫øn v·ªã tr√≠ =====
  function buildTOC(navs){
    clearTOC();
    const add = items => items.forEach(it=>{
      const a = document.createElement('a');
      a.textContent = (it.label||'').trim() || '(no title)';
      a.href = '#';
      a.addEventListener('click', e=>{
        e.preventDefault();
        // epub.js ch·∫•p nh·∫≠n href (link) ho·∫∑c CFI. V·ªõi toc.href l√† link spine, d√πng tr·ª±c ti·∫øp:
        rendition.display(it.href);
      });
      tocItems.appendChild(a);
      if (it.subitems?.length) add(it.subitems);
    });
    add(navs.toc || []);
  }

  function escapeHtml(s){
    return (s||'').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  }

  // ===== Panel highlights render =====
  function renderNotes(){
    noteList.innerHTML = '';
    if (!highlights.length){
      noteList.innerHTML = '<div style="opacity:.7">Ch∆∞a c√≥ highlight n√†o.</div>';
      return;
    }
    for (const h of highlights){
      const item = document.createElement('div');
      item.className = 'note';
      item.innerHTML = `
        <div class="row">
          <button class="jump" title="Nh·∫£y t·ªõi v·ªã tr√≠">${escapeHtml(h.text || '(tr·ªëng)')}</button>
          <button class="del" title="Xo√° highlight">üóëÔ∏è</button>
        </div>
        <small>${escapeHtml(h.chapter || '')}</small>
      `;
      // jump
      item.querySelector('.jump').addEventListener('click', ()=> rendition.display(h.cfi));
      // delete
      item.querySelector('.del').addEventListener('click', ()=>{
        removeHighlight(h.id);
      });
      noteList.appendChild(item);
    }
  }

  // ===== Th√™m/Xo√° highlight trong viewer + list =====
  function addHighlightObj(cfi, text, chapter){
    const id = 'hl-' + (idSeq++);
    // th√™m v√†o viewer
    rendition.annotations.add('highlight', cfi, {}, null, id);
    // l∆∞u v√†o store
    highlights.push({ id, cfi, text, chapter });
    renderNotes();
    setStatus('ƒê√£ th√™m highlight.');
  }

  function removeHighlight(id){
    const idx = highlights.findIndex(h => h.id === id);
    if (idx < 0) return;
    const h = highlights[idx];
    // remove t·ª´ viewer
    try{ rendition.annotations.remove(h.cfi, 'highlight', h.id); }catch(e){}
    // remove kh·ªèi store
    highlights.splice(idx,1);
    renderNotes();
    setStatus('ƒê√£ xo√° highlight.');
  }

  // ===== Binding rendition events =====
  function bindRendition(){
    rendition.on('relocated', (e) => {
      try{ const p = e.location.start.displayed; loc.textContent = p.page + '/' + p.total; }
      catch{ loc.textContent = '‚Äî'; }
    });

    // user select text trong iframe
    rendition.on('selected', async (cfiRange, contents) => {
      try{
        const range = await rendition.getRange(cfiRange);
        const txt = (range?.toString() || '').trim().replace(/\s+/g,' ').slice(0, 300);
        lastSelection = { cfi: cfiRange, text: txt };
        addHLBtn.disabled = false;
      }catch{
        lastSelection = { cfi: cfiRange, text: '' };
        addHLBtn.disabled = false;
      }finally{
        try{ contents.window.getSelection().removeAllRanges(); }catch{}
      }
    });

    rendition.themes.default({
      'body': { 'line-height': '1.6', 'color': '#eaf0ff' },
      'a': { 'color': '#9ad1ff' }
    });
    applyFont(); area.focus();
  }

  function applyFont(){ rendition?.themes.fontSize(fontRange.value + '%'); }

  function unloadBook(){
    rendition?.destroy(); book?.destroy();
    rendition = null; book = null; clearTOC(); loc.textContent = '‚Äî';
    highlights.length = 0; renderNotes();
    lastSelection = null; addHLBtn.disabled = true; exportBtn.disabled = true;
    currentEpubName = currentEpubBase = '';
  }

  // ===== m·ªü EPUB t·ª´ ArrayBuffer =====
  async function openArrayBuffer(buf, fileName){
    unloadBook();
    overlay.style.display='grid'; setStatus('ƒêang m·ªü EPUB‚Ä¶');

    try{
      if (!window.JSZip) throw new Error('JSZip lib not loaded');
      currentEpubName = fileName || 'book.epub';
      currentEpubBase = currentEpubName.replace(/\.[Ee][Pp][Uu][Bb]$/, '');
      exportBtn.disabled = false;

      book = ePub(buf);
      rendition = book.renderTo(area, { width: area.clientWidth, height: area.clientHeight, flow:'paginated' });
      await rendition.display();

      bindRendition();
      const navs = await book.loaded.navigation;
      buildTOC(navs);

      setStatus('ƒê√£ t·∫£i xong: ' + currentEpubName);
    }catch(err){
      alert('Kh√¥ng th·ªÉ m·ªü file EPUB.\n\nChi ti·∫øt:\n' + (err?.message || err));
      setStatus('L·ªói khi m·ªü EPUB');
      console.error(err);
    }finally{
      overlay.style.display='none';
    }
  }

  // ====== Export / Import ======
  function exportHighlights(){
    if (!currentEpubBase){
      alert('H√£y m·ªü EPUB tr∆∞·ªõc khi xu·∫•t d·ªØ li·ªáu.'); return;
    }
    const data = {
      epub_name: currentEpubName,
      epub_base: currentEpubBase,
      created_at: new Date().toISOString(),
      highlights: highlights.map(h => ({ id:h.id, cfi:h.cfi, text:h.text, chapter:h.chapter }))
    };
    const blob = new Blob([JSON.stringify(data, null, 2)], {type:'application/json'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = currentEpubBase + '.json';
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 0);
  }

  async function importHighlightsFile(file){
    if (!currentEpubBase){
      alert('H√£y m·ªü EPUB (Ch·ªçn file .epub) tr∆∞·ªõc khi Nh·∫≠p d·ªØ li·ªáu.'); return;
    }
    try{
      const text = await file.text();
      const data = JSON.parse(text);

      // T√™n ph·∫£i kh·ªõp base
      const base = (data?.epub_base || '').trim();
      if (!base || base !== currentEpubBase){
        alert('Ch·ªçn l·∫°i file kh√°c: t√™n d·ªØ li·ªáu kh√¥ng tr√πng v·ªõi EPUB hi·ªán t·∫°i.\n\nEPUB hi·ªán t·∫°i: ' + currentEpubBase + '\nFile d·ªØ li·ªáu: ' + (base || '(kh√¥ng x√°c ƒë·ªãnh)'));
        return;
      }

      // n·∫°p highlights
      highlights.length = 0;
      idSeq = 1;
      for (const h of (data.highlights || [])){
        const id = h.id || ('hl-' + (idSeq++));
        try{ rendition.annotations.add('highlight', h.cfi, {}, null, id); }catch(e){}
        highlights.push({ id, cfi:h.cfi, text:h.text, chapter:h.chapter });
      }
      renderNotes();
      setStatus('Nh·∫≠p d·ªØ li·ªáu: Th√†nh c√¥ng');
      alert('Th√†nh c√¥ng');
    }catch(err){
      console.error(err);
      alert('Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c file JSON.\n' + (err?.message || err));
    }
  }

  // ====== Events ======
  fileInput.addEventListener('change', async e=>{
    const f = e.target.files?.[0]; if (!f) return;
    const ab = await f.arrayBuffer(); openArrayBuffer(ab, f.name);
  });

  prevBtn.addEventListener('click', ()=> rendition?.prev());
  nextBtn.addEventListener('click', ()=> rendition?.next());
  fontRange.addEventListener('input', applyFont);

  addHLBtn.addEventListener('click', ()=>{
    if (!lastSelection) return;
    // c·ªë g·∫Øng ƒëo√°n chapter theo v·ªã tr√≠ hi·ªán t·∫°i (ƒë∆°n gi·∫£n)
    let chapter = '';
    try{
      const href = rendition.currentLocation()?.start?.href || '';
      const nav = book && book.navigation ? book.navigation.toc : null;
      if (nav){
        const found = nav.find(n => href.endsWith(n.href));
        if (found) chapter = found.label || '';
      }
    }catch{}
    addHighlightObj(lastSelection.cfi, lastSelection.text, chapter);
    lastSelection = null;
    addHLBtn.disabled = true;
  });

  exportBtn.addEventListener('click', exportHighlights);
  importFile.addEventListener('change', e=>{
    const f = e.target.files?.[0]; if (!f) return;
    importHighlightsFile(f);
    importFile.value = ''; // reset ƒë·ªÉ l·∫ßn sau ch·ªçn l·∫°i v·∫´n trigger
  });

  // DnD EPUB
  ;['dragenter','dragover'].forEach(t=>area.addEventListener(t, e=>{e.preventDefault(); overlay.style.display='grid';}));
  ;['dragleave','dragend','drop'].forEach(t=>area.addEventListener(t, e=>{e.preventDefault(); overlay.style.display='none';}));
  area.addEventListener('drop', async e=>{
    const f = e.dataTransfer.files?.[0];
    if (f && f.name.toLowerCase().endsWith('.epub')) {
      const ab = await f.arrayBuffer(); openArrayBuffer(ab, f.name);
    } else setStatus('File kh√¥ng h·ª£p l·ªá. H√£y th·∫£ .epub');
  });

  // ph√≠m t·∫Øt
  window.addEventListener('keydown', e=>{
    if (!rendition) return;
    if (e.key === 'ArrowLeft') rendition.prev();
    if (e.key === 'ArrowRight') rendition.next();
    if (e.key.toLowerCase()==='h' && !addHLBtn.disabled) addHLBtn.click();
  });
})();
</script>
</body>
</html>
